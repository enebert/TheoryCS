* 8/13/25 - Read Chapter 1. It motivates computability by giving basic definitions of total and partial functions. The motivation is then continued through the Halting problem and a short description of diagonalization, as it is a well-used tool in computability theory. The book uses a subset of Pascal for its While Programs. This isn't a distraction as it looks like a lot of algorithm presentations. However, it could be a distraction to the modern student if they looked at Pascal as an artifact of the past. It might be worthwhile to assign a set of homework problems that asked the student to translate the Pascal in the book into a language that students have experience with. 
* 8/15/25 - Wrote notes on the first chapter. They can be found here: [Chapter 1](./KMA%20Notes/Chapter%201.md) The notes contain some related material that isn't covered in the book.
* 8/16/25 - Read Chapter 2. The chapter describes while loop programs and gives some examples. The authors end the chapter with a restatement of Church's thesis for while loop programs. There are some exercises that are perhaps worth doing for someone trying to get an initial introduction to the area such as proving that the set of "goto" programs and the set of "flowchart" programs are equivalent.
* 8/17/25 - Wrote notes on the second chapter. They can be found here: [Chapter 2](./KMA%20Notes/Chapter%202.md). In functional programming languages, one does not get to change state. In my Haskell code, I have taken variable assignment as a given instead of trying to go through a ```State``` monad or some other abstraction. 
* 8/18/25 - Some implementations in Haskell can be found here: [Computable Functions Module](./KMA%20Notes/CompFuncs.hs)
* 8/21/25 - Posted notes about computable functions. Notes on Haskell, the State Monad, and notes on control structures in While-programs can be found [here](./KMA%20Notes/Control.md). I think that if I were teaching a course over this material that I would do the setup all at once instead of doling it out a little bit at a time. I understand the issues around covering a system all at once, but I don't think it's worth starting with being allowed equality test and then modifying the system to allow $>$ and $<$. 
* 8/25/2025 - Read the section on the $s$-$m$-$n$ theorem. I've certainly seen this theorem in the other readings that I've done over the summer. I don't think I ever really had a good sense of what's going on though. The equation

    $$
        \phi_i(y_1, \ldots, y_m,z_1, \ldots, z_n) = \phi_{s_m^n(i,y_1,\ldots y_m)}(z_1, \ldots , z_n)
    $$

    Is in some sense saying, we can "pull down" (this is the phrase the book uses) $m$ variables to the parameter block. This parametrization is not unique, but it is quite useful. Another way to look at it is, we can use the total computable function $s_m^n$ to calculate the index of a program that takes $(z_1, \ldots, z_n)$ as an input and calculates the function on the left-hand-side. The section then goes into using the $s$-$m$-$n$ theorem to produce the index for a composition of computable functions.
    * 8/27/25 - Finished reading chapter 4 on decision problems. These are standard examples using diagonalization and reducibility to show that a decision problem isn't decidable or that a function related to a decision problem isn't effectively computable. They prove that there exists a total computable function $\mathbb{N} \rightarrow \mathbb{N}$ that does not lie in an effective enumeration. The reducibility results are similar to the decision problem: Given to programs $P$ and $P'$, decide if $P$ and $P'$ compute the same function.
    * 8/28/25 - Posted notes for chapter 4.
